#!/usr/bin/octave


function radians = C(x)
	radians = cos(x);
endfunction

function radians = S(x)
	radians = sin(x);
endfunction

function euler = quat_to_euler(quat)
	w = quat(1);
	x = quat(2);
	y = quat(3);
	z = quat(4);

	# euler 321 (ZYX)
	euler = [
		atan2((y * z + w * x), 0.5 - (x * x + y * y));
        asin(-2 * (z * x - w * y));
        atan2((x * y + w * z), 0.5 - (y * y + z * z));
	];
endfunction

function quat = euler_to_quat(ypr)
	# euler 321 (ZYX)
	r = 0.5 * ypr(3);
	p = 0.5 * ypr(2);
	y = 0.5 * ypr(1);

	quat = [
		S(y) * S(p) * S(r) + C(y) * C(p) * C(r);
		-S(y) * S(p) * C(r) + S(r) * C(p) * C(y);
		S(y) * S(r) * C(p) + S(p) * C(y) * C(r);
		S(y) * C(p) * C(r) - S(p) * S(r) * C(y);
	];
endfunction

function quat = quat_normalize(q)
	w = q(1);
	x = q(2);
	y = q(3);
	z = q(4);

	mag = sqrt(w^2 + x^2 + y^2 + z^2);
	quat = [w / mag; x / mag; y / mag; z / mag];
endfunction


# aero-convention 3-2-1 Euler Angles
roll = 0.0;
pitch = 0.0;
yaw = 0.0;
mat_roll = [
	1.0, 0.0, 0.0;
	0.0, cos(roll), -sin(roll);
	0.0, sin(roll), cos(roll);
];

mat_pitch = [
	cos(pitch), 0.0, sin(pitch),
	0.0, 1.0, 0.0,
	-sin(pitch), 0.0, cos(pitch);
];

mat_yaw = [
	cos(yaw), -sin(yaw), 0.0;
	sin(yaw), cos(yaw), 0.0;
	0.0, 0.0, 1.0;
];

rot_mat = mat_yaw * mat_pitch * mat_roll;  # right most is evaluated first



ypr = [0.0, 0.1, 0.0]
quat = euler_to_quat(ypr)
euler = quat_to_euler(quat)
