{
    "docs": [
        {
            "location": "/", 
            "text": "awesomo \n\n\nLanding a quadrotor on a moving platform.\n\n\nInstall\n\n\nThe following instructions assumes you have installed ROS.\n\n\ncd \nyour catkin workspace\n/src\ngit clone https://github.com/wavelab/awesomo\ncatkin_build\n\n\n\nIn short the above navigates to your catkin workspace's \nsrc\n, clones \nawesomo\n\nand finally runs \ncatkin_build\n.\n\n\nLicence\n\n\nLicence LGPL License Copyright (C) \n2016\n Chris Choi, Stan Brown\n\n\nThis program is free software: you can redistribute it and/or modify it under\nthe terms of the Lesser GNU General Public License as published by the Free\nSoftware Foundation, either version 3 of the License, or (at your option) any\nlater version.\n\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\nA PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\n\nYou should have received a copy of the GNU General Public License along with\nthis program.  If not, see \nhttp://www.gnu.org/licenses/\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#awesomo", 
            "text": "Landing a quadrotor on a moving platform.", 
            "title": "awesomo"
        }, 
        {
            "location": "/#install", 
            "text": "The following instructions assumes you have installed ROS.  cd  your catkin workspace /src\ngit clone https://github.com/wavelab/awesomo\ncatkin_build  In short the above navigates to your catkin workspace's  src , clones  awesomo \nand finally runs  catkin_build .", 
            "title": "Install"
        }, 
        {
            "location": "/#licence", 
            "text": "Licence LGPL License Copyright (C)  2016  Chris Choi, Stan Brown  This program is free software: you can redistribute it and/or modify it under\nthe terms of the Lesser GNU General Public License as published by the Free\nSoftware Foundation, either version 3 of the License, or (at your option) any\nlater version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\nA PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with\nthis program.  If not, see  http://www.gnu.org/licenses/ .", 
            "title": "Licence"
        }, 
        {
            "location": "/api/apriltag/", 
            "text": "apriltag.hpp\n\n\nClasses\n:\n- TagPose\n- TagDetector\n\n\nTagPose\n\n\nAttributes\n:\n\n\n\n\nint id\n\n\ndouble distance\n\n\ndouble yaw\n\n\ndouble pitch\n\n\ndouble roll\n\n\nEigen::Vector3d translation\n\n\n\n\nTagDetector\n\n\nConstructors\n\n\nTagDetector(void)\nTagDetector(int apriltag_imshow)\n\n\n\nMethods\n\n\nvoid adjustROI(cv::Mat \nimage_gray, AprilTags::TagDetection \ntag)\n\n\n\nAdjust the Region of Interest (ROI) within \nimage_gray\n with \ntag\n detected.\nThis essentially blacks out the whole image apart from the detected Apriltag.\nThe intuition is to decrease the image area where the apriltag library has to\nfind the Apriltag.\n\n\n\n\nstd::vector\nTagPose\n processImage\n    cv::Mat \ncamera_matrix,\n    cv::Mat \nimage,\n    int \ntimeout\n);\n\n\n\nProcess image frame \nimage\n and uses \ncamera_matrix\n to estimate the Apriltags\nif any was detected. The \ntimeout\n argument is used to keep track how many\nimage frames where Apriltags was not detected.\n\n\n\n\nTagPose obtainPose(\n    AprilTags::TagDetection \ndetection,\n    cv::Mat camera_matrix\n)\n\n\n\nObtain Apriltag pose from detected tag \ndetection\n and \ncamera_matrix\n.\n\n\n\n\nvoid printDetection(\n    AprilTags::TagDetection \ndetection,\n    cv::Mat camera_matrix\n)\n\n\n\nPrint detected apriltags.", 
            "title": "apriltag"
        }, 
        {
            "location": "/api/apriltag/#apriltaghpp", 
            "text": "Classes :\n- TagPose\n- TagDetector", 
            "title": "apriltag.hpp"
        }, 
        {
            "location": "/api/apriltag/#tagpose", 
            "text": "Attributes :   int id  double distance  double yaw  double pitch  double roll  Eigen::Vector3d translation", 
            "title": "TagPose"
        }, 
        {
            "location": "/api/apriltag/#tagdetector", 
            "text": "", 
            "title": "TagDetector"
        }, 
        {
            "location": "/api/apriltag/#constructors", 
            "text": "TagDetector(void)\nTagDetector(int apriltag_imshow)", 
            "title": "Constructors"
        }, 
        {
            "location": "/api/apriltag/#methods", 
            "text": "void adjustROI(cv::Mat  image_gray, AprilTags::TagDetection  tag)  Adjust the Region of Interest (ROI) within  image_gray  with  tag  detected.\nThis essentially blacks out the whole image apart from the detected Apriltag.\nThe intuition is to decrease the image area where the apriltag library has to\nfind the Apriltag.   std::vector TagPose  processImage\n    cv::Mat  camera_matrix,\n    cv::Mat  image,\n    int  timeout\n);  Process image frame  image  and uses  camera_matrix  to estimate the Apriltags\nif any was detected. The  timeout  argument is used to keep track how many\nimage frames where Apriltags was not detected.   TagPose obtainPose(\n    AprilTags::TagDetection  detection,\n    cv::Mat camera_matrix\n)  Obtain Apriltag pose from detected tag  detection  and  camera_matrix .   void printDetection(\n    AprilTags::TagDetection  detection,\n    cv::Mat camera_matrix\n)  Print detected apriltags.", 
            "title": "Methods"
        }, 
        {
            "location": "/api/camera/", 
            "text": "camera.hpp\n\n\nClasses\n:\n- CameraConfig\n- Camera\n\n\nCameraConfig\n\n\nThis class is mainly used as a data container to store the camera\nproperties, such as image width, image height, camera matrix, etc.\n\n\nAttributes\n\n\n\n\nint camera_mode\n\n\nint image_width\n\n\nint image_height\n\n\ncv::Mat camera_matrix\n\n\ncv::Mat rectification_matrix\n\n\ncv::Mat distortion_coefficients\n\n\ncv::Mat projection_matrix\n\n\n\n\nCamera\n\n\nThis class provides the functionalty to connect to any normal OpenCV compatible\ncamera as well as a PointGrey FireFly camera. In addition to obtaining camera\naccess it also performs AprilTag detection where the pose estimates are store\nin \nCamera::pose_estimates\n.\n\n\nAttributes\n\n\n\n\nvector\nAprilTags::TagDetection\n apriltags\n\n\nstd::vector\nTagPose\n pose_estimates\n\n\n\n\nConstructor\n\n\n\n\nCamera(int camera_index, int camera_type)\n\n\nCamera(std::string camera_config_path)\n\n\n\n\nMethods\n\n\nint initCamera(std::string camera_mode)\n\n\n\nInitialize Camera to be ready to start getting images from the camera. This\nmethod does not get images from camera yet, for that look at \nCamera::run()\n or\n\nCamera::step()\n.\n\n\nThere are two accepted \ncamera_mode\n values:\n- firefly\n- normal\n\n\n\n\nCameraConfig *loadConfig(std::string mode, const std::string calib_file)\n\n\n\nLoad the configuration into the camera class where \nmode\n is the key or name of\nthe mode, and \ncalib_file\n is the path to the camera calibration file (yaml)\nproduced by ROS's \ncamera_calibration\n package.\n\n\n\n\nint loadConfig(std::string camera_mode)\n\n\n\nThis overloaded method differs from the above method in that this is meant to\nbe called to change the incoming image size dynamically. Where \ncamera_mode\n is\nthe key / name used to load the camera calibration file.\n\n\n\n\nint getFrame(cv::Mat \nimage)\n\n\n\nObtains a single image frame from the camera, the captured image will be set to\n\nimage\n. Returns \n0\n or \n-1\n to denote success or failure.\n\n\n\n\nint run(void)\n\n\n\nRun Camera and attempt to detect any Apriltags. The AprilTags detected will be\nrecorded in \nCamera::apriltags\n.\n\n\n\n\nstd::vector\nTagPose\n step(int \ntimeout)\n\n\n\nStep differs to \nCamera::run()\n where it only obatins a single image frame and\nperforms apriltag detection on that same image frame and returns a vector of\n\nTagPose\n objects if any apriltag is detected. \ntimeout\n is an integer\ndenoting the number of image frames where an apriltag was not detected.", 
            "title": "camera"
        }, 
        {
            "location": "/api/camera/#camerahpp", 
            "text": "Classes :\n- CameraConfig\n- Camera", 
            "title": "camera.hpp"
        }, 
        {
            "location": "/api/camera/#cameraconfig", 
            "text": "This class is mainly used as a data container to store the camera\nproperties, such as image width, image height, camera matrix, etc.", 
            "title": "CameraConfig"
        }, 
        {
            "location": "/api/camera/#attributes", 
            "text": "int camera_mode  int image_width  int image_height  cv::Mat camera_matrix  cv::Mat rectification_matrix  cv::Mat distortion_coefficients  cv::Mat projection_matrix", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/camera/#camera", 
            "text": "This class provides the functionalty to connect to any normal OpenCV compatible\ncamera as well as a PointGrey FireFly camera. In addition to obtaining camera\naccess it also performs AprilTag detection where the pose estimates are store\nin  Camera::pose_estimates .", 
            "title": "Camera"
        }, 
        {
            "location": "/api/camera/#attributes_1", 
            "text": "vector AprilTags::TagDetection  apriltags  std::vector TagPose  pose_estimates", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/camera/#constructor", 
            "text": "Camera(int camera_index, int camera_type)  Camera(std::string camera_config_path)", 
            "title": "Constructor"
        }, 
        {
            "location": "/api/camera/#methods", 
            "text": "int initCamera(std::string camera_mode)  Initialize Camera to be ready to start getting images from the camera. This\nmethod does not get images from camera yet, for that look at  Camera::run()  or Camera::step() .  There are two accepted  camera_mode  values:\n- firefly\n- normal   CameraConfig *loadConfig(std::string mode, const std::string calib_file)  Load the configuration into the camera class where  mode  is the key or name of\nthe mode, and  calib_file  is the path to the camera calibration file (yaml)\nproduced by ROS's  camera_calibration  package.   int loadConfig(std::string camera_mode)  This overloaded method differs from the above method in that this is meant to\nbe called to change the incoming image size dynamically. Where  camera_mode  is\nthe key / name used to load the camera calibration file.   int getFrame(cv::Mat  image)  Obtains a single image frame from the camera, the captured image will be set to image . Returns  0  or  -1  to denote success or failure.   int run(void)  Run Camera and attempt to detect any Apriltags. The AprilTags detected will be\nrecorded in  Camera::apriltags .   std::vector TagPose  step(int  timeout)  Step differs to  Camera::run()  where it only obatins a single image frame and\nperforms apriltag detection on that same image frame and returns a vector of TagPose  objects if any apriltag is detected.  timeout  is an integer\ndenoting the number of image frames where an apriltag was not detected.", 
            "title": "Methods"
        }, 
        {
            "location": "/api/controller/", 
            "text": "controller.hpp\n\n\n\n\nStructures\n\n\nClasses\n\n\n\n\nStructures\n\n\nstruct pid\n{\n    int sample_rate;\n\n    float setpoint;\n    float output;\n\n    float prev_error;\n    float sum_error;\n\n    float p_error;\n    float i_error;\n    float d_error;\n\n    float k_p;\n    float k_i;\n    float k_d;\n\n    float dead_zone;\n    float min;\n    float max;\n};\n\n\n\nClasses\n\n\n\n\nCarrotController\n\n\nPositionController\n\n\n\n\nCarrotController\n\n\nAttributes\n\n\n\n\nstd::deque\nEigen::Vector3d\n waypoints\n\n\nint initialized\n\n\ndouble look_ahead_dist\n\n\ndouble wp_threshold\n\n\nEigen::Vector3d wp_start\n\n\nEigen::Vector3d wp_end\n\n\n\n\nConstructors\n\n\nCarrotController();\nCarrotController(\n    std::deque\nEigen::Vector3d\n waypoints,\n    double look_ahead_dist,\n    double wp_threshold\n);\nCarrotController(std::string config_file_path);\n\n\n\nMethods\n\n\nEigen::Vector3d closestPoint(\n    Eigen::Vector3d position,\n    Eigen::Vector3d wp_start,\n    Eigen::Vector3d wp_end\n);\n\n\n\nCalculates the closest point on the trajectory line formed by \nwp_start\n and\n\nwp_end\n relative to \nposition\n.\n\n\n\n\nEigen::Vector3d calculateCarrotPoint(\n    Eigen::Vector3d position,\n    double r,\n    Eigen::Vector3d wp_start,\n    Eigen::Vector3d wp_end\n);\n\n\n\nCalculate new carrot point based on \nposition\n, look ahead distance \nr\n and\ntrajectory line formed by \nwp_start\n and \nwp_end\n.\n\n\n\n\nint waypointReached(\n    Eigen::Vector3d position,\n    Eigen::Vector3d waypoint,\n    double threshold\n);\n\n\n\nReturns \n0\n or \n1\n to denote whether waypoint has been reached.\n\n\n\n\nint update(Eigen::Vector3d position, Eigen::Vector3d \ncarrot);\n\n\n\nThis method is meant to be executed within a loop that constantly updates the\nrobot's \nposition\n, where \ncarrot\n is the carrot point to be updated. Returns\n\n0\n or \n-1\n for success or failure.\n\n\n\n\nPositionController\n\n\nAttribute\n\n\n\n\nstruct pid x\n\n\nstruct pid y\n\n\nstruct pid T\n\n\nfloat roll\n\n\nfloat pitch\n\n\nfloat throttle\n\n\nfloat hover_throttle\n\n\ntf::Quaternion rpy_quat\n\n\nfloat dt\n\n\n\n\nConstructor\n\n\nPositionController(const std::string config_file);\n\n\n\nMethods\n\n\nvoid loadConfig(const std::string config_file);\n\n\n\nLoad \nconfig_file\n where it defines the position controller configurations.\n\n\n\n\nvoid calculate(Pose p);\n\n\n\nCalculates new \nPositionController::roll\n, \nPositionController::pitch\n and\n\nPositionController::throttle\n values for the inner loop (atitude controller),\nbased on the robot's current pose \np\n.", 
            "title": "controller"
        }, 
        {
            "location": "/api/controller/#controllerhpp", 
            "text": "Structures  Classes", 
            "title": "controller.hpp"
        }, 
        {
            "location": "/api/controller/#structures", 
            "text": "struct pid\n{\n    int sample_rate;\n\n    float setpoint;\n    float output;\n\n    float prev_error;\n    float sum_error;\n\n    float p_error;\n    float i_error;\n    float d_error;\n\n    float k_p;\n    float k_i;\n    float k_d;\n\n    float dead_zone;\n    float min;\n    float max;\n};", 
            "title": "Structures"
        }, 
        {
            "location": "/api/controller/#classes", 
            "text": "CarrotController  PositionController", 
            "title": "Classes"
        }, 
        {
            "location": "/api/controller/#carrotcontroller", 
            "text": "", 
            "title": "CarrotController"
        }, 
        {
            "location": "/api/controller/#attributes", 
            "text": "std::deque Eigen::Vector3d  waypoints  int initialized  double look_ahead_dist  double wp_threshold  Eigen::Vector3d wp_start  Eigen::Vector3d wp_end", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/controller/#constructors", 
            "text": "CarrotController();\nCarrotController(\n    std::deque Eigen::Vector3d  waypoints,\n    double look_ahead_dist,\n    double wp_threshold\n);\nCarrotController(std::string config_file_path);", 
            "title": "Constructors"
        }, 
        {
            "location": "/api/controller/#methods", 
            "text": "Eigen::Vector3d closestPoint(\n    Eigen::Vector3d position,\n    Eigen::Vector3d wp_start,\n    Eigen::Vector3d wp_end\n);  Calculates the closest point on the trajectory line formed by  wp_start  and wp_end  relative to  position .   Eigen::Vector3d calculateCarrotPoint(\n    Eigen::Vector3d position,\n    double r,\n    Eigen::Vector3d wp_start,\n    Eigen::Vector3d wp_end\n);  Calculate new carrot point based on  position , look ahead distance  r  and\ntrajectory line formed by  wp_start  and  wp_end .   int waypointReached(\n    Eigen::Vector3d position,\n    Eigen::Vector3d waypoint,\n    double threshold\n);  Returns  0  or  1  to denote whether waypoint has been reached.   int update(Eigen::Vector3d position, Eigen::Vector3d  carrot);  This method is meant to be executed within a loop that constantly updates the\nrobot's  position , where  carrot  is the carrot point to be updated. Returns 0  or  -1  for success or failure.", 
            "title": "Methods"
        }, 
        {
            "location": "/api/controller/#positioncontroller", 
            "text": "", 
            "title": "PositionController"
        }, 
        {
            "location": "/api/controller/#attribute", 
            "text": "struct pid x  struct pid y  struct pid T  float roll  float pitch  float throttle  float hover_throttle  tf::Quaternion rpy_quat  float dt", 
            "title": "Attribute"
        }, 
        {
            "location": "/api/controller/#constructor", 
            "text": "PositionController(const std::string config_file);", 
            "title": "Constructor"
        }, 
        {
            "location": "/api/controller/#methods_1", 
            "text": "void loadConfig(const std::string config_file);  Load  config_file  where it defines the position controller configurations.   void calculate(Pose p);  Calculates new  PositionController::roll ,  PositionController::pitch  and PositionController::throttle  values for the inner loop (atitude controller),\nbased on the robot's current pose  p .", 
            "title": "Methods"
        }, 
        {
            "location": "/api/util/", 
            "text": "util.hpp\n\n\nContent\n:\n- Classes\n- Functions\n\n\nClasses\n\n\n\n\nPose\n\n\nPosition\n\n\n\n\nPose\n\n\nAttributes\n\n\n\n\ndouble x\n\n\ndouble y\n\n\ndouble z\n\n\ndouble roll\n\n\ndouble pitch\n\n\ndouble yaw\n\n\n\n\nPosition\n\n\nAttributes\n\n\n\n\ndouble x;\n\n\ndouble y;\n\n\ndouble z;\n\n\n\n\nFunctions\n\n\ndouble deg2rad(double d);\n\n\n\nConvert degrees \nd\n to radians.\n\n\n\n\ndouble rad2deg(double r);\n\n\n\nConvert radians \nr\n to degrees.\n\n\n\n\nint euler2Quaternion(\n    const double roll,\n    const double pitch,\n    const double yaw,\n    Eigen::Quaterniond \nq\n);\n\n\n\nConvert Euler angles in radians to quaternions \nq\n. Returns \n0\n or \n-1\n to\ndenote success or failure.\n\n\n\n\nint euler2RotationMatrix(\n    const double roll,\n    const double pitch,\n    const double yaw,\n    Eigen::Matrix3d \nrot\n);\n\n\n\nConvert Euler angles in radians to rotation matrix \nrot\n. Returns \n0\n or \n-1\n to\ndenote success or failure.\n\n\n\n\ntf::Quaternion euler2quat(double roll, double pitch, double yaw);\n\n\n\nConvert Euler angles in radians to quaternions, the difference to\n\neuler2Quaternion\n is this function returns a \ntf::Quaternion\n instead of\na \nEigen::Quaterniond\n.\n\n\n\n\nvoid quat2euler(\n    const geometry_msgs::Quaternion \nq,\n    double *roll,\n    double *pitch,\n    double *yaw\n);\n\n\n\nConvert quaternion to Euler angles in radians.", 
            "title": "util"
        }, 
        {
            "location": "/api/util/#utilhpp", 
            "text": "Content :\n- Classes\n- Functions", 
            "title": "util.hpp"
        }, 
        {
            "location": "/api/util/#classes", 
            "text": "Pose  Position", 
            "title": "Classes"
        }, 
        {
            "location": "/api/util/#pose", 
            "text": "", 
            "title": "Pose"
        }, 
        {
            "location": "/api/util/#attributes", 
            "text": "double x  double y  double z  double roll  double pitch  double yaw", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/util/#position", 
            "text": "", 
            "title": "Position"
        }, 
        {
            "location": "/api/util/#attributes_1", 
            "text": "double x;  double y;  double z;", 
            "title": "Attributes"
        }, 
        {
            "location": "/api/util/#functions", 
            "text": "double deg2rad(double d);  Convert degrees  d  to radians.   double rad2deg(double r);  Convert radians  r  to degrees.   int euler2Quaternion(\n    const double roll,\n    const double pitch,\n    const double yaw,\n    Eigen::Quaterniond  q\n);  Convert Euler angles in radians to quaternions  q . Returns  0  or  -1  to\ndenote success or failure.   int euler2RotationMatrix(\n    const double roll,\n    const double pitch,\n    const double yaw,\n    Eigen::Matrix3d  rot\n);  Convert Euler angles in radians to rotation matrix  rot . Returns  0  or  -1  to\ndenote success or failure.   tf::Quaternion euler2quat(double roll, double pitch, double yaw);  Convert Euler angles in radians to quaternions, the difference to euler2Quaternion  is this function returns a  tf::Quaternion  instead of\na  Eigen::Quaterniond .   void quat2euler(\n    const geometry_msgs::Quaternion  q,\n    double *roll,\n    double *pitch,\n    double *yaw\n);  Convert quaternion to Euler angles in radians.", 
            "title": "Functions"
        }, 
        {
            "location": "/reference/odroid/flashing/", 
            "text": "Odroid Flashing\n\n\nThe following will detail how to flash a linux distro onto the eMMC or MicroSD\nand boot.\n\n\n1.) Uncompress the \n.xz\n file\n\n\nunxz file.image.xz\n\n\n\nNote: this replaces the \n.xz\n file to \n.img\n\n\n2.) Write the image to eMMC or MicroSD with \ndd\n\n\nsudo dd if=\n/path/to/img\n of=\n/dev/of/card/\n bs=1M conv=fsync\nsync; sync; sync;\n\n\n\nThe \nsync\n command is very important, as it flushes all cached data, this\ncommand has to be executed multiple times to ensure all data is all flushed.\n\n\nNOTE: Many SD-to-MicroSD adapter don't work correctly. You need to connect the\nflash storage to your USB reader directly.", 
            "title": "Flashing"
        }, 
        {
            "location": "/reference/odroid/flashing/#odroid-flashing", 
            "text": "The following will detail how to flash a linux distro onto the eMMC or MicroSD\nand boot.  1.) Uncompress the  .xz  file  unxz file.image.xz  Note: this replaces the  .xz  file to  .img  2.) Write the image to eMMC or MicroSD with  dd  sudo dd if= /path/to/img  of= /dev/of/card/  bs=1M conv=fsync\nsync; sync; sync;  The  sync  command is very important, as it flushes all cached data, this\ncommand has to be executed multiple times to ensure all data is all flushed.  NOTE: Many SD-to-MicroSD adapter don't work correctly. You need to connect the\nflash storage to your USB reader directly.", 
            "title": "Odroid Flashing"
        }, 
        {
            "location": "/reference/odroid/resize_partition/", 
            "text": "Odroid Partition Resize\n\n\nOn a freshly flashed Odriod with Ubuntu image, it is most likely the image only\nutilizes 4GB of the eMMC or SD card you're using. To resize the paritition run\nthe following script:\n\n\nsave the script as \nresize.sh\n, give it execution rights with:\n\n\nchmod +x resize.sh\n\n\n\nthen run the script by:\n\n\nsudo ./resize.sh", 
            "title": "Resize Partition"
        }, 
        {
            "location": "/reference/odroid/resize_partition/#odroid-partition-resize", 
            "text": "On a freshly flashed Odriod with Ubuntu image, it is most likely the image only\nutilizes 4GB of the eMMC or SD card you're using. To resize the paritition run\nthe following script:  save the script as  resize.sh , give it execution rights with:  chmod +x resize.sh  then run the script by:  sudo ./resize.sh", 
            "title": "Odroid Partition Resize"
        }, 
        {
            "location": "/reference/pixhawk/serial_communication/", 
            "text": "Pixhawk Serial Communication\n\n\nPixhawk has a system console allows low-level access to the system, debug\noutput and analysis of the system boot process. The most robost method is to\ncommunicate via serial, by using a USB FTDI (connected to the computer) to\nPixhawk's serial port (aka UART port; Serial 4/5 port)\n\n\nNote: check which version of the pixhawk you have, you can find out by opening\nthe enclosure of the pixhawk and find the version number on the PCB. (see image\nbelow)\n\n\n\n\nFTDI to Pixhawk Serial 4/5 pinout\n\n\n\n\nConnect to Pixhawk via Serial\n\n\nAssuming you are using Linux (which you should), you can communicate via serial\nusing the \nscreen\n command.\n\n\n# install GNU Screen if you don't have it (Ubuntu/Debian)\nsudo apt-get install screen\n\n# connect to Pixhawk, assuming the FTDI board or cable is connected to\n# /dev/ttyUSB0 with baud rate of 57600 and 8bits No parity\nscreen /dev/ttyUSB0 57600 8N1\n\n\n\nVERY IMPORTANT NOTE: You may get a blank screen upon successful execution, press the\n\"Enter\" key three times to activate the USB on the pixhawk, then you\nshould get the following output\n\n\nnsh", 
            "title": "Serial Communication"
        }, 
        {
            "location": "/reference/pixhawk/serial_communication/#pixhawk-serial-communication", 
            "text": "Pixhawk has a system console allows low-level access to the system, debug\noutput and analysis of the system boot process. The most robost method is to\ncommunicate via serial, by using a USB FTDI (connected to the computer) to\nPixhawk's serial port (aka UART port; Serial 4/5 port)  Note: check which version of the pixhawk you have, you can find out by opening\nthe enclosure of the pixhawk and find the version number on the PCB. (see image\nbelow)", 
            "title": "Pixhawk Serial Communication"
        }, 
        {
            "location": "/reference/pixhawk/serial_communication/#ftdi-to-pixhawk-serial-45-pinout", 
            "text": "", 
            "title": "FTDI to Pixhawk Serial 4/5 pinout"
        }, 
        {
            "location": "/reference/pixhawk/serial_communication/#connect-to-pixhawk-via-serial", 
            "text": "Assuming you are using Linux (which you should), you can communicate via serial\nusing the  screen  command.  # install GNU Screen if you don't have it (Ubuntu/Debian)\nsudo apt-get install screen\n\n# connect to Pixhawk, assuming the FTDI board or cable is connected to\n# /dev/ttyUSB0 with baud rate of 57600 and 8bits No parity\nscreen /dev/ttyUSB0 57600 8N1  VERY IMPORTANT NOTE: You may get a blank screen upon successful execution, press the\n\"Enter\" key three times to activate the USB on the pixhawk, then you\nshould get the following output  nsh", 
            "title": "Connect to Pixhawk via Serial"
        }, 
        {
            "location": "/reference/pointgrey/install/", 
            "text": "PointGrey Install\n\n\nInstall Pointgrey camera drivers\n\n\nsudo apt-get install ros-indigo-pointgrey-camera-driver\n\n\n\nAdd a udev rule (one line)\n\n\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1e10\", ATTRS{idProduct}==\"2002\",\nGROUP=\"plugdev\", SYMLINK+=\"firefly\", MODE:=\"0666\"\n\n\n\nRestart udev\n\n\nsudo service udev restart\n\n\n\nCheck to see if camera is detected\n\n\nrosrun pointgrey_camera_driver list_cameras\n\n\n\nRun the camera with\n\n\nroslaunch pointgrey_camera_driver camera.launch", 
            "title": "Install"
        }, 
        {
            "location": "/reference/pointgrey/install/#pointgrey-install", 
            "text": "Install Pointgrey camera drivers  sudo apt-get install ros-indigo-pointgrey-camera-driver  Add a udev rule (one line)  SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1e10\", ATTRS{idProduct}==\"2002\",\nGROUP=\"plugdev\", SYMLINK+=\"firefly\", MODE:=\"0666\"  Restart udev  sudo service udev restart  Check to see if camera is detected  rosrun pointgrey_camera_driver list_cameras  Run the camera with  roslaunch pointgrey_camera_driver camera.launch", 
            "title": "PointGrey Install"
        }
    ]
}